{"version":3,"sources":["webpack://NFBWebPlayer/./node_modules/@silvermine/videojs-quality-selector/src/js/components/QualityOption.js","webpack://NFBWebPlayer/./node_modules/@silvermine/videojs-quality-selector/src/js/components/QualitySelector.js","webpack://NFBWebPlayer/./node_modules/@silvermine/videojs-quality-selector/src/js/events.js","webpack://NFBWebPlayer/./node_modules/@silvermine/videojs-quality-selector/src/js/index.js","webpack://NFBWebPlayer/./node_modules/@silvermine/videojs-quality-selector/src/js/middleware/SourceInterceptor.js","webpack://NFBWebPlayer/./node_modules/@silvermine/videojs-quality-selector/src/js/util/SafeSeek.js"],"names":["_","events","module","exports","videojs","MenuItem","getComponent","extend","constructor","player","options","source","isObject","Error","selectable","label","call","this","handleClick","event","prototype","trigger","QUALITY_REQUESTED","qualityOptionFactory","QUALITY_CHANGE_CLASS","QualitySelector","MenuButton","QualityOption","on","newSource","setSelectedSource","addClass","one","removeClass","bind","PLAYER_SOURCES_CHANGED","update","QUALITY_SELECTED","selectedSrc","src","controlText","undefined","each","items","item","selected","createItems","sources","currentSources","length","map","buildWrapperCSSClass","registerComponent","qualitySelectorFactory","sourceInterceptorFactory","SafeSeek","window","hook","currentTime","currentPlaybackRate","playbackRate","isPaused","paused","findWhere","_qualitySelectorSafeSeek","onQualitySelectionChange","ready","hasFinished","play","EVENTS","use","setSource","playerSelectedSource","next","chosenSource","onPlayerSourcesChange","isEqual","_qualitySelectorPreviousSources","find","Class","init","seekToTime","_player","_seekToTime","_hasFinished","_keepThisInstanceWhenPlayerSourcesChange","_seekWhenSafe","readyState","_seekFn","_seek","cancel","off"],"mappings":"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","file":"videojs-mp4-quality-selector.b4510eb470b755c8bad8.js","sourcesContent":["'use strict';\n\nvar _ = require('underscore'),\n    events = require('../events');\n\nmodule.exports = function(videojs) {\n   var MenuItem = videojs.getComponent('MenuItem');\n\n   /**\n    * A MenuItem to represent a video resolution\n    *\n    * @class QualityOption\n    * @extends videojs.MenuItem\n    */\n   return videojs.extend(MenuItem, {\n\n      /**\n       * @inheritdoc\n       */\n      constructor: function(player, options) {\n         var source = options.source;\n\n         if (!_.isObject(source)) {\n            throw new Error('was not provided a \"source\" object, but rather: ' + (typeof source));\n         }\n\n         options = _.extend({\n            selectable: true,\n            label: source.label,\n         }, options);\n\n         MenuItem.call(this, player, options);\n\n         this.source = source;\n      },\n\n      /**\n       * @inheritdoc\n       */\n      handleClick: function(event) {\n         MenuItem.prototype.handleClick.call(this, event);\n         this.player().trigger(events.QUALITY_REQUESTED, this.source);\n      },\n\n   });\n};\n","'use strict';\n\nvar _ = require('underscore'),\n    events = require('../events'),\n    qualityOptionFactory = require('./QualityOption'),\n    QUALITY_CHANGE_CLASS = 'vjs-quality-changing';\n\nmodule.exports = function(videojs) {\n   var MenuButton = videojs.getComponent('MenuButton'),\n       QualityOption = qualityOptionFactory(videojs),\n       QualitySelector;\n\n   /**\n    * A component for changing video resolutions\n    *\n    * @class QualitySelector\n    * @extends videojs.Button\n    */\n   QualitySelector = videojs.extend(MenuButton, {\n\n      /**\n       * @inheritdoc\n       */\n      constructor: function(player, options) {\n         MenuButton.call(this, player, options);\n\n         // Update interface instantly so the user's change is acknowledged\n         player.on(events.QUALITY_REQUESTED, function(event, newSource) {\n            this.setSelectedSource(newSource);\n            player.addClass(QUALITY_CHANGE_CLASS);\n\n            player.one('loadeddata', function() {\n               player.removeClass(QUALITY_CHANGE_CLASS);\n            });\n         }.bind(this));\n\n         // Update the list of menu items only when the list of sources change\n         player.on(events.PLAYER_SOURCES_CHANGED, function() {\n            this.update();\n         }.bind(this));\n\n         player.on(events.QUALITY_SELECTED, function(event, newSource) {\n            // Update the selected source with the source that was actually selected\n            this.setSelectedSource(newSource);\n         }.bind(this));\n\n         // Since it's possible for the player to get a source before the selector is\n         // created, make sure to update once we get a \"ready\" signal.\n         player.one('ready', function() {\n            this.selectedSrc = player.src();\n            this.update();\n         }.bind(this));\n\n         this.controlText('Open quality selector menu');\n      },\n\n      /**\n       * Updates the source that is selected in the menu\n       *\n       * @param source {object} player source to display as selected\n       */\n      setSelectedSource: function(source) {\n         var src = (source ? source.src : undefined);\n\n         if (this.selectedSrc !== src) {\n            this.selectedSrc = src;\n            _.each(this.items, function(item) {\n               item.selected(item.source.src === src);\n            });\n         }\n      },\n\n      /**\n       * @inheritdoc\n       */\n      createItems: function() {\n         var player = this.player(),\n             sources = player.currentSources();\n\n         if (!sources || sources.length < 2) {\n            return [];\n         }\n\n         return _.map(sources, function(source) {\n            return new QualityOption(player, {\n               source: source,\n               selected: source.src === this.selectedSrc,\n            });\n         }.bind(this));\n      },\n\n      /**\n       * @inheritdoc\n       */\n      buildWrapperCSSClass: function() {\n         return 'vjs-quality-selector ' + MenuButton.prototype.buildWrapperCSSClass.call(this);\n      },\n\n   });\n\n   videojs.registerComponent('QualitySelector', QualitySelector);\n\n   return QualitySelector;\n};\n","'use strict';\n\nmodule.exports = {\n\n   QUALITY_REQUESTED: 'qualityRequested',\n   QUALITY_SELECTED: 'qualitySelected',\n   PLAYER_SOURCES_CHANGED: 'playerSourcesChanged',\n\n};\n","'use strict';\n\nvar _ = require('underscore'),\n    events = require('./events'),\n    qualitySelectorFactory = require('./components/QualitySelector'),\n    sourceInterceptorFactory = require('./middleware/SourceInterceptor'),\n    SafeSeek = require('./util/SafeSeek');\n\nmodule.exports = function(videojs) {\n   videojs = videojs || window.videojs;\n\n   qualitySelectorFactory(videojs);\n   sourceInterceptorFactory(videojs);\n\n   videojs.hook('setup', function(player) {\n      function changeQuality(event, newSource) {\n         var sources = player.currentSources(),\n             currentTime = player.currentTime(),\n             currentPlaybackRate = player.playbackRate(),\n             isPaused = player.paused(),\n             selectedSource;\n\n         // Clear out any previously selected sources (see: #11)\n         _.each(sources, function(source) {\n            source.selected = false;\n         });\n\n         selectedSource = _.findWhere(sources, { src: newSource.src });\n         // Note: `_.findWhere` returns a reference to an object. Thus the\n         // following updates the original object in `sources`.\n         selectedSource.selected = true;\n\n         if (player._qualitySelectorSafeSeek) {\n            player._qualitySelectorSafeSeek.onQualitySelectionChange();\n         }\n\n         player.src(sources);\n\n         player.ready(function() {\n            if (!player._qualitySelectorSafeSeek || player._qualitySelectorSafeSeek.hasFinished()) {\n               // Either we don't have a pending seek action or the one that we have is no\n               // longer applicable. This block must be within a `player.ready` callback\n               // because the call to `player.src` above is asynchronous, and so not\n               // having it within this `ready` callback would cause the SourceInterceptor\n               // to execute after this block instead of before.\n               //\n               // We save the `currentTime` within the SafeSeek instance because if\n               // multiple QUALITY_REQUESTED events are received before the SafeSeek\n               // operation finishes, the player's `currentTime` will be `0` if the\n               // player's `src` is updated but the player's `currentTime` has not yet\n               // been set by the SafeSeek operation.\n               player._qualitySelectorSafeSeek = new SafeSeek(player, currentTime);\n               player.playbackRate(currentPlaybackRate);\n            }\n\n            if (!isPaused) {\n               player.play();\n            }\n         });\n      }\n\n      // Add handler to switch sources when the user requests a change\n      player.on(events.QUALITY_REQUESTED, changeQuality);\n   });\n};\n\nmodule.exports.EVENTS = events;\n","'use strict';\n\nvar _ = require('underscore'),\n    events = require('../events');\n\nmodule.exports = function(videojs) {\n\n   videojs.use('*', function(player) {\n\n      return {\n\n         setSource: function(playerSelectedSource, next) {\n            var sources = player.currentSources(),\n                userSelectedSource, chosenSource;\n\n            if (player._qualitySelectorSafeSeek) {\n               player._qualitySelectorSafeSeek.onPlayerSourcesChange();\n            }\n\n            if (!_.isEqual(sources, player._qualitySelectorPreviousSources)) {\n               player.trigger(events.PLAYER_SOURCES_CHANGED, sources);\n               player._qualitySelectorPreviousSources = sources;\n            }\n\n            // There are generally two source options, the one that videojs\n            // auto-selects and the one that a \"user\" of this plugin has\n            // supplied via the `selected` property. `selected` can come from\n            // either the `<source>` tag or the list of sources passed to\n            // videojs using `src()`.\n\n            userSelectedSource = _.find(sources, function(source) {\n               // Must check for boolean values as well as either the string 'true' or\n               // 'selected'. When sources are set programmatically, the value will be a\n               // boolean, but those coming from a `<source>` tag will be a string.\n               return source.selected === true || source.selected === 'true' || source.selected === 'selected';\n            });\n\n            chosenSource = userSelectedSource || playerSelectedSource;\n\n            player.trigger(events.QUALITY_SELECTED, chosenSource);\n\n            // Pass along the chosen source\n            next(null, chosenSource);\n         },\n\n      };\n\n   });\n\n};\n","'use strict';\n\nvar Class = require('class.extend');\n\nmodule.exports = Class.extend({\n   init: function(player, seekToTime) {\n      this._player = player;\n      this._seekToTime = seekToTime;\n      this._hasFinished = false;\n      this._keepThisInstanceWhenPlayerSourcesChange = false;\n      this._seekWhenSafe();\n   },\n\n   _seekWhenSafe: function() {\n      var HAVE_FUTURE_DATA = 3;\n\n      // `readyState` in Video.js is the same as the HTML5 Media element's `readyState`\n      // property.\n      //\n      // `readyState` is an enum of 5 values (0-4), each of which represent a state of\n      // readiness to play. The meaning of the values range from HAVE_NOTHING (0), meaning\n      // no data is available to HAVE_ENOUGH_DATA (4), meaning all data is loaded and the\n      // video can be played all the way through.\n      //\n      // In order to seek successfully, the `readyState` must be at least HAVE_FUTURE_DATA\n      // (3).\n      //\n      // @see http://docs.videojs.com/player#readyState\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState\n      // @see https://dev.w3.org/html5/spec-preview/media-elements.html#seek-the-media-controller\n      if (this._player.readyState() < HAVE_FUTURE_DATA) {\n         this._seekFn = this._seek.bind(this);\n         // The `canplay` event means that the `readyState` is at least HAVE_FUTURE_DATA.\n         this._player.one('canplay', this._seekFn);\n      } else {\n         this._seek();\n      }\n   },\n\n   onPlayerSourcesChange: function() {\n      if (this._keepThisInstanceWhenPlayerSourcesChange) {\n         // By setting this to `false`, we know that if the player sources change again\n         // the change did not originate from a quality selection change, the new sources\n         // are likely different from the old sources, and so this pending seek no longer\n         // applies.\n         this._keepThisInstanceWhenPlayerSourcesChange = false;\n      } else {\n         this.cancel();\n      }\n   },\n\n   onQualitySelectionChange: function() {\n      // `onPlayerSourcesChange` will cancel this pending seek unless we tell it not to.\n      // We need to reuse this same pending seek instance because when the player is\n      // paused, the `preload` attribute is set to `none`, and the user selects one\n      // quality option and then another, the player cannot seek until the player has\n      // enough data to do so (and the `canplay` event is fired) and thus on the second\n      // selection the player's `currentTime()` is `0` and when the video plays we would\n      // seek to `0` instead of the correct time.\n      if (!this.hasFinished()) {\n         this._keepThisInstanceWhenPlayerSourcesChange = true;\n      }\n   },\n\n   _seek: function() {\n      this._player.currentTime(this._seekToTime);\n      this._keepThisInstanceWhenPlayerSourcesChange = false;\n      this._hasFinished = true;\n   },\n\n   hasFinished: function() {\n      return this._hasFinished;\n   },\n\n   cancel: function() {\n      this._player.off('canplay', this._seekFn);\n      this._keepThisInstanceWhenPlayerSourcesChange = false;\n      this._hasFinished = true;\n   },\n});\n"],"sourceRoot":""}